# filename: newp/browser_use/browser/views.py
from dataclasses import dataclass, field
from typing import Any, List, Optional # Explicitly import List

from pydantic import BaseModel

from browser_use.dom.history_tree_processor.view import DOMHistoryElement
from browser_use.dom.views import DOMState

# Pydantic model for Tab Information (assuming it's defined in this file or imported)
class TabInfo(BaseModel):
    """Represents information about a browser tab."""
    page_id: int
    url: str
    title: str
    parent_page_id: Optional[int] = None


@dataclass
class BrowserState(DOMState):
    """
    Represents the comprehensive current state of the browser's active page/context.
    """
    url: str
    title: str
    tabs: List[TabInfo] 
    screenshot: Optional[str] = None 
    pixels_above: int = 0 
    pixels_below: int = 0 
    browser_errors: List[str] = field(default_factory=list) 

    def to_history(self, interacted_elements: Optional[List[Optional[DOMHistoryElement]]] = None) -> 'BrowserStateHistory':
        """Converts a live BrowserState to a BrowserStateHistory."""
        # Need to import BrowserStateHistory here if not already, or use forward ref if defined later in file
        return BrowserStateHistory(
            url=self.url,
            title=self.title,
            tabs=self.tabs, # Assumes tabs are already List[TabInfo]
            interacted_element=interacted_elements or [],
            screenshot=self.screenshot
        )


@dataclass
class BrowserStateHistory:
    """
    A snapshot of the browser's state recorded at a specific point in an agent's execution history.
    """
    url: str
    title: str
    tabs: List[TabInfo] 
    interacted_element: List[Optional[DOMHistoryElement]] = field(default_factory=list)
    screenshot: Optional[str] = None 

    def to_dict(self) -> dict[str, Any]:
        """Serializes the BrowserStateHistory to a dictionary, suitable for JSON storage."""
        return {
            'url': self.url,
            'title': self.title,
            'tabs': [tab.model_dump() for tab in self.tabs], 
            'interacted_element': [el.to_dict() if el else None for el in self.interacted_element],
            'screenshot': self.screenshot,
        }

class BrowserError(Exception):
	"""Base class for all custom browser-related errors encountered during automation."""
	pass


class URLNotAllowedError(BrowserError):
	"""
	Error raised when an attempted navigation or access to a URL is blocked
	due to security policies (e.g., domain allowlist).
	"""
	def __init__(self, url: str, allowed_domains: Optional[List[str]] = None):
		message = f"Navigation to URL '{url}' is not allowed by the current policy."
		if allowed_domains:
			message += f" Allowed domains include: {', '.join(allowed_domains)}."
		super().__init__(message)
		self.url = url
		self.allowed_domains = allowed_domains