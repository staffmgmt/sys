# filename: newp/browser_use/controller/service.py
# Error handling pattern:
# - Tools/actions defined herein return ActionResult objects with success=False and error messages for operational failures.
# - Deeper infrastructure or setup errors might raise specific exceptions from browser_use.exceptions.
import asyncio
import enum
import json
import logging
import re
import uuid # For PDF naming
from pathlib import Path # For PDF saving
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, cast
import hashlib

from langchain_core.language_models.chat_models import BaseChatModel
from langchain_core.prompts import PromptTemplate
# Assuming patchright is used by BrowserContext, Page might not be directly needed here
# from patchright.async_api import ElementHandle, Page
from pydantic import BaseModel, Field as PydanticField

from browser_use.agent.views import ActionResult # ActionModel base is from controller.registry.views
from browser_use.browser.context import BrowserContext
from browser_use.controller.registry.service import Registry
from browser_use.controller.registry.views import ActionModel # The base for dynamic models

# Action parameter models from controller.views.py
from browser_use.controller.views import (
    ClickElementAction,
    CloseTabAction,
    DoneAction,
    DragDropAction,
    GoToUrlAction,
    InputTextAction,
    NoParamsAction, # Also used as SavePdfActionParams
    OpenTabAction,
    Position as DragDropPositionParam,
    SearchGoogleAction,
    SendKeysAction,
    SwitchTabAction,
    FileParameters, # Corrected import source
    ReadFileParameters, # Corrected import source
    ExcelParameters, # Corrected import source
    LaunchNotepadParameters # Corrected import source
)

# Import exceptions and functions from local_pc_tools
from browser_use.local_pc_tools import (
    ToolError as LocalPCToolError, # Alias to avoid name clash if controller has own ToolError
    FileNotFoundInAgentDir,
    InvalidPathError,
    FileOperationError as LocalPCFileOperationError, # Alias
    ToolConfigurationError as LocalPCToolConfigurationError, # Alias
    list_agent_files as pc_tool_list_agent_files,
    read_agent_text_file as pc_tool_read_agent_text_file,
    write_agent_text_file as pc_tool_write_agent_text_file,
    read_excel_file as pc_tool_read_excel_file,
    write_excel_file as pc_tool_write_excel_file,
    launch_notepad as pc_tool_launch_notepad
)
from browser_use.utils import time_execution_async

logger = logging.getLogger(__name__)
Context = TypeVar('Context')

# --- Define Pydantic Models for Action Parameters ---
# These should ideally be in controller/views.py but are defined here based on the "pasted version" structure
# if they aren't already present there.

class ExtractContentActionParams(BaseModel):
    goal: str
    should_strip_link_urls: bool = PydanticField(default=True)

class ScrollActionWithDirection(BaseModel): # Replaces original ScrollAction
    direction: str = PydanticField(description="Direction to scroll: 'up', 'down', 'top', or 'bottom'.")
    amount: Optional[int] = PydanticField(None, description="Pixel amount for 'up'/'down'. If None, scrolls one viewport height.")

class ScrollToTextActionParams(BaseModel):
    text: str

class GetDropdownOptionsActionParams(BaseModel):
    index: int

class SelectDropdownOptionActionParams(BaseModel):
    index: int
    text: str # The visible text of the option to select

class WaitActionParams(BaseModel):
    seconds: int = PydanticField(default=3, ge=0, le=300) # Added reasonable max for wait

# save_pdf usually takes NoParamsAction, filename generated internally
SavePdfActionParams = NoParamsAction


class Controller(Generic[Context]):

    def _create_action_result(
        self,
        action_name: str,
        parameters: Optional[Dict[str, Any]],
        success: bool,
        is_done: bool = False,
        extracted_data: Optional[Any] = None, # Renamed from 'data' for clarity
        error_message: Optional[str] = None,
        include_in_memory: bool = True
    ) -> ActionResult:
        """
        Helper to construct ActionResult consistently.
        Populates extracted_content and raw_tool_outputs from extracted_data.
        """
        extracted_content_str: Optional[str] = None
        raw_tool_outputs_dict: Optional[Dict[str, Any]] = None

        if success and extracted_data is not None:
            if isinstance(extracted_data, str):
                extracted_content_str = extracted_data
            elif isinstance(extracted_data, (list, tuple)):
                try:
                    # For LLM, a JSON string is usually best for complex list/dict data.
                    extracted_content_str = json.dumps(extracted_data, ensure_ascii=False)
                    # Store the original list/tuple in raw_tool_outputs
                    raw_tool_outputs_dict = {"list_data": extracted_data}
                except TypeError:
                    extracted_content_str = str(extracted_data) # Fallback
                    raw_tool_outputs_dict = {"stringified_list_data": extracted_content_str}
            elif isinstance(extracted_data, dict):
                raw_tool_outputs_dict = extracted_data # Store the original dictionary
                # Try to find a primary piece of text for extracted_content_str
                if 'message' in extracted_data and isinstance(extracted_data['message'], str):
                    extracted_content_str = extracted_data['message']
                elif 'summary' in extracted_data and isinstance(extracted_data['summary'], str):
                    extracted_content_str = extracted_data['summary']
                elif 'content' in extracted_data and isinstance(extracted_data['content'], str):
                    extracted_content_str = extracted_data['content']
                elif 'filename' in extracted_data and isinstance(extracted_data['filename'], str): # For file operations
                    extracted_content_str = f"Operation resulted in file: {extracted_data['filename']}"
                # If no specific content key, provide a JSON summary of the dict
                if extracted_content_str is None:
                    try:
                        extracted_content_str = f"Tool output (JSON): {json.dumps(extracted_data, ensure_ascii=False)}"
                    except TypeError:
                        extracted_content_str = f"Tool output (stringified): {str(extracted_data)}"
            else: # Fallback for other data types
                extracted_content_str = str(extracted_data)
        
        if error_message is not None and not isinstance(error_message, str):
            error_message = str(error_message)

        # Ensure parameters are serializable (e.g. if they contain Pydantic models)
        serializable_parameters = {}
        if parameters:
            for k, v in parameters.items():
                if hasattr(v, 'model_dump'): # Check if it's a Pydantic model
                    serializable_parameters[k] = v.model_dump()
                else:
                    try:
                        # Check if serializable, otherwise convert to string
                        json.dumps({k: v}) 
                        serializable_parameters[k] = v
                    except TypeError:
                        serializable_parameters[k] = str(v)


        return ActionResult(
            action_name=action_name,
            parameters=serializable_parameters if serializable_parameters else parameters,
            success=success,
            is_done=is_done,
            extracted_content=extracted_content_str,
            error=error_message,
            include_in_memory=include_in_memory,
            raw_tool_outputs=raw_tool_outputs_dict
        )

    def __init__(
        self,
        exclude_actions: List[str] = [],
    ):
        self.registry = Registry[Context](exclude_actions)
        self._register_actions() # Call helper to register all actions

    def _register_actions(self):
        """Register all default browser actions and local PC tools."""

        # --- Task Completion Action ---
        @self.registry.action(
            'Signals that the entire task is complete. Provide a final answer or summary, and indicate if the task was successful.',
            param_model=DoneAction, # Assumes DoneAction.text is Optional[str] as per system prompt
        )
        async def done(params: DoneAction, browser: BrowserContext) -> ActionResult: # Added browser for uniform injection if needed
            # The action 'done' itself is successfully executed.
            # params.success reflects the success of the overall task.
            return self._create_action_result(
                action_name="done",
                parameters=params.model_dump(),
                success=True, 
                is_done=True, 
                extracted_data={'message': params.text or "Task marked as done.", 'overall_task_success': params.success},
                include_in_memory=False # Final message isn't typically for next LLM context
            )

        # --- Basic Browser Navigation Actions ---
        @self.registry.action(
            'Search the provided query in Google in the current tab. The query should be concise and specific.',
            param_model=SearchGoogleAction,
        )
        async def search_google(params: SearchGoogleAction, browser: BrowserContext) -> ActionResult:
            action_name="search_google"
            try:
                page = await browser.get_current_page()
                await page.goto(f'https://www.google.com/search?q={params.query}&udm=14') # udm=14 for web results
                await page.wait_for_load_state('domcontentloaded', timeout=30000)
                msg = f'Searched for "{params.query}" in Google.'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error during search_google for '{params.query}': {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Navigate to the specified URL in the current tab.', param_model=GoToUrlAction)
        async def go_to_url(params: GoToUrlAction, browser: BrowserContext) -> ActionResult:
            action_name="go_to_url"
            try:
                page = await browser.get_current_page()
                await page.goto(params.url, wait_until='domcontentloaded', timeout=60000) # Increased timeout
                msg = f'Navigated to {params.url}'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'current_url': page.url})
            except Exception as e:
                logger.error(f"Error navigating to URL '{params.url}': {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Navigate back to the previous page in the current tab history.', param_model=NoParamsAction)
        async def go_back(_: NoParamsAction, browser: BrowserContext) -> ActionResult:
            action_name = "go_back"
            try:
                await browser.go_back() 
                current_page = await browser.get_current_page()
                await current_page.wait_for_load_state('domcontentloaded', timeout=30000)
                msg = f'Navigated back. Current URL: {current_page.url}'
                logger.info(msg)
                return self._create_action_result(action_name, {}, success=True, extracted_data={'message': msg, 'current_url': current_page.url})
            except Exception as e:
                logger.error(f"Error navigating back: {e}", exc_info=True)
                return self._create_action_result(action_name, {}, success=False, error_message=str(e))

        @self.registry.action('Wait for a specified number of seconds (default is 3, max 300).', param_model=WaitActionParams)
        async def wait(params: WaitActionParams, browser: BrowserContext) -> ActionResult: # Added browser for consistency
            action_name = "wait"
            try:
                msg = f'Waiting for {params.seconds} seconds.'
                logger.info(msg)
                await asyncio.sleep(params.seconds)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error during wait: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Click the interactive element specified by its index on the current page.', param_model=ClickElementAction)
        async def click_element_by_index(params: ClickElementAction, browser: BrowserContext) -> ActionResult:
            action_name = "click_element_by_index"
            try:
                selector_map = await browser.get_selector_map()
                if params.index not in selector_map:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f'Element with index {params.index} not found in prior observation map.')

                element_node = await browser.get_dom_element_by_index(params.index)
                if not element_node: 
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f'Could not retrieve DOMElementNode for index {params.index}.')

                original_fingerprint = element_node.get_fingerprint()

                # Locate the element live to check fingerprint before clicking
                element_handle = await browser.get_locate_element(element_node)
                if not element_handle:
                    error_msg = f"Element at index {params.index} (Fingerprint: {original_fingerprint}) could not be located on the current page for interaction."
                    logger.warning(error_msg)
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=error_msg)

                js_script_for_fingerprint = """
                e => {
                    const text = e.textContent?.trim().slice(0, 50) || '';
                    const cls = e.getAttribute('class') || '';
                    return `${e.tagName.toLowerCase()}:${text}:${cls}`;
                }
                """
                current_fingerprint_str_from_js = await element_handle.evaluate(js_script_for_fingerprint)
                current_fingerprint_dynamic = hashlib.md5(current_fingerprint_str_from_js.encode()).hexdigest()[:12]

                if current_fingerprint_dynamic != original_fingerprint:
                    warning_msg = f"Element at index {params.index} has changed since observation! Fingerprint mismatch. Original: '{original_fingerprint}', Current: '{current_fingerprint_dynamic}'. Action aborted."
                    logger.warning(warning_msg)
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=warning_msg, extracted_content="Element changed, click aborted.")
                
                # Fingerprint matches, proceed with click
                page = await browser.get_current_page()
                initial_pages_count = len(page.context.pages)
                
                # The original is_file_uploader check was:
                # if await browser.is_file_uploader(element_node):
                # This check might now be less relevant if _click_element_node handles it,
                # or it could be adapted to use element_handle if still needed.
                # For now, proceeding directly to _click_element_node.

                download_path = await browser._click_element_node(element_node) 
                
                element_text_preview = element_node.get_all_text_till_next_clickable_element(max_depth=2)

                msg_main = f'Clicked element with index {params.index} ("{element_text_preview}").'
                full_message = msg_main
                if download_path:
                    full_message += f' A file download was triggered: {download_path}'
                
                logger.info(full_message)
                
                final_data = {'message': full_message}
                if download_path: final_data['downloaded_file'] = download_path

                if len(page.context.pages) > initial_pages_count:
                    new_tab_msg = 'A new tab was opened and focus has been switched to it.'
                    final_data['message'] += f" {new_tab_msg}" # Append to existing message
                    logger.info(new_tab_msg)
                    # Ensure BrowserContext handles active tab switching if a new tab is opened by click
                    # This might need await browser.switch_to_tab(len(page.context.pages) - 1) if not automatic

                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data=final_data)
            except Exception as e:
                # Log with more context if element_node was available
                element_repr = repr(element_node) if 'element_node' in locals() and element_node else f"index {params.index}"
                logger.warning(f"Error clicking element {element_repr}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action(
			'Input text into an interactive element (e.g., text field) specified by its index.',
			param_model=InputTextAction,
		)
        async def input_text(params: InputTextAction, browser: BrowserContext, sensitive_data: Optional[Dict[str,str]] = None) -> ActionResult:
            # sensitive_data is passed by registry.execute_action if available in Agent.
            # Here we just use params.text; actual redaction for logging if needed should be handled by agent or careful param construction.
            action_name = "input_text"
            log_text_param = params.text # For logging, could be masked if known sensitive
            if sensitive_data and "<secret>" in params.text : # A very basic check if the text itself contains placeholder
                log_text_display = "[SENSITIVE DATA]"
            else:
                log_text_display = f'"{log_text_param}"'

            try:
                selector_map = await browser.get_selector_map()
                if params.index not in selector_map:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f'Element with index {params.index} not found.')

                element_node = await browser.get_dom_element_by_index(params.index)
                await browser._input_text_element_node(element_node, params.text)
                
                msg = f'Input text {log_text_display} into element at index {params.index} ({element_node.tag_name}).'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error inputting text {log_text_display} into element at index {params.index}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Save the current page as a PDF file. Filename is auto-generated.', param_model=SavePdfActionParams)
        async def save_pdf(params: SavePdfActionParams, browser: BrowserContext) -> ActionResult:
            action_name = "save_pdf"
            try:
                page = await browser.get_current_page()
                page_title = await page.title() or "untitled"
                slug_title = re.sub(r'[^\w\s-]', '', page_title.lower()).strip().replace(' ', '-')[:50]
                timestamp = int(asyncio.get_event_loop().time())
                # This should save to Agent_Dir via a local_pc_tool ideally
                # For now, relative to CWD.
                pdf_filename = f"{slug_title}_{timestamp}.pdf"
                
                await page.emulate_media(media='screen')
                pdf_bytes = await page.pdf(format='A4', print_background=True)

                # To save to Agent_Dir correctly:
                # await pc_tool_write_agent_binary_file(filename=pdf_filename, content_bytes=pdf_bytes)
                # For now, let's assume we save it locally and report the name.
                # This is a placeholder for direct saving. For agent use, writing to Agent_Dir is better.
                with open(pdf_filename, "wb") as f:
                    f.write(pdf_bytes)
                
                msg = f'Saved current page ({page.url}) as PDF: "{pdf_filename}" (in current directory).'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'filename': pdf_filename})
            except Exception as e:
                logger.error(f"Error saving page as PDF: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        # --- Tab Management Actions ---
        @self.registry.action('Switch focus to an existing tab using its page_id.', param_model=SwitchTabAction)
        async def switch_tab(params: SwitchTabAction, browser: BrowserContext) -> ActionResult:
            action_name = "switch_tab"
            try:
                await browser.switch_to_tab(params.page_id)
                page = await browser.get_current_page()
                await page.wait_for_load_state('domcontentloaded', timeout=30000)
                msg = f'Switched to tab {params.page_id} (URL: {page.url}).'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'current_url': page.url, 'current_page_id': params.page_id})
            except Exception as e:
                logger.error(f"Error switching to tab {params.page_id}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Open a URL in a new tab and switch focus to it.', param_model=OpenTabAction)
        async def open_tab(params: OpenTabAction, browser: BrowserContext) -> ActionResult:
            action_name = "open_tab"
            try:
                await browser.create_new_tab(params.url) # Assumes this switches focus
                page = await browser.get_current_page()
                await page.wait_for_load_state('domcontentloaded', timeout=60000)
                # Need a way to get the new page_id from BrowserContext if create_new_tab doesn't return it
                tabs_info = await browser.get_tabs_info()
                new_tab_info = next((t for t in tabs_info if t.url == page.url), None) # Simplistic match
                new_page_id = new_tab_info.page_id if new_tab_info else -1

                msg = f'Opened new tab for {params.url} (ID: {new_page_id}). Focus switched.'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'new_page_id': new_page_id, 'url': page.url})
            except Exception as e:
                logger.error(f"Error opening new tab for URL '{params.url}': {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action('Close an existing tab using its page_id.', param_model=CloseTabAction)
        async def close_tab(params: CloseTabAction, browser: BrowserContext) -> ActionResult:
            action_name = "close_tab"
            try:
                # This logic needs BrowserContext to have a robust way to get page by ID and close it.
                # Simplified:
                all_pages = browser.session.context.pages if browser.session else []
                if not (0 <= params.page_id < len(all_pages)):
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Invalid page_id {params.page_id} or browser session not found.")
                
                if len(all_pages) <= 1:
                     return self._create_action_result(action_name, params.model_dump(), success=False, error_message="Cannot close the last remaining tab.")

                page_to_close = all_pages[params.page_id]
                url_closed = page_to_close.url
                
                # If closing active tab, BrowserContext should handle switching to another, or agent needs to.
                is_active_tab = (browser.active_tab == page_to_close)
                
                await page_to_close.close()
                
                # Update active_tab in BrowserContext if the closed one was active
                if is_active_tab:
                    browser.active_tab = None # Mark as None, get_current_page will find a new one
                    if browser.session and browser.session.context.pages: # Check if any pages left
                         await browser.switch_to_tab(0) # Switch to first available, for instance

                msg = f'Closed tab page_id {params.page_id} (URL: {url_closed}).'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'closed_page_id': params.page_id})
            except Exception as e:
                logger.error(f"Error closing tab {params.page_id}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        # --- Unified Scroll Action ---
        @self.registry.action(
            "Scrolls the current page. Direction can be 'up', 'down', 'top', or 'bottom'. 'amount' is in pixels for 'up'/'down' (optional, defaults to viewport height).",
            param_model=ScrollActionWithDirection,
        )
        async def scroll_action(params: ScrollActionWithDirection, browser: BrowserContext) -> ActionResult:
            action_name = "scroll_action"
            page = await browser.get_current_page()
            direction = params.direction.lower()
            amount_desc = ""
            try:
                if direction == 'down':
                    scroll_value = params.amount if params.amount is not None else "window.innerHeight"
                    await page.evaluate(f'window.scrollBy(0, {scroll_value});')
                    amount_desc = f"by {params.amount} pixels" if params.amount is not None else "by one page height"
                elif direction == 'up':
                    scroll_value = params.amount if params.amount is not None else "window.innerHeight"
                    await page.evaluate(f'window.scrollBy(0, -{scroll_value});')
                    amount_desc = f"by {params.amount} pixels" if params.amount is not None else "by one page height"
                elif direction == 'top':
                    await page.evaluate('window.scrollTo(0, 0);')
                    amount_desc = "to top"
                elif direction == 'bottom':
                    await page.evaluate('window.scrollTo(0, document.body.scrollHeight);')
                    amount_desc = "to bottom"
                else:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Invalid scroll direction: '{params.direction}'.")

                await asyncio.sleep(0.5) # Allow render after scroll
                msg = f'Scrolled page {direction} {amount_desc}'.strip() + '.'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error scrolling {direction}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        # --- Content & Other Page Actions ---
        @self.registry.action(
			'Extracts textual content from the current page, guided by a specific goal or question. If the goal is vague, it summarizes the page.',
            param_model=ExtractContentActionParams
		)
        async def extract_content(params: ExtractContentActionParams, browser: BrowserContext, page_extraction_llm: Optional[BaseChatModel]) -> ActionResult:
            action_name = "extract_content"
            if not page_extraction_llm:
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message="Page extraction LLM not available.")
            try:
                page = await browser.get_current_page()
                import markdownify

                strip_tags_list = ['script', 'style', 'nav', 'footer', 'aside']
                if params.should_strip_link_urls: strip_tags_list.extend(['a', 'img'])
                
                html_content = await page.content()
                text_content = markdownify.markdownify(html_content, strip=strip_tags_list, heading_style='atx')
                
                # Simplified iframe content inclusion
                for frame in page.frames:
                    if frame != page.main_frame and not frame.url.startswith("data:"):
                        try:
                            text_content += f"\n\n--- IFRAME: {frame.url} ---\n" + markdownify.markdownify(await frame.content(), strip=strip_tags_list, heading_style='atx')
                        except Exception: pass # Ignore frames that can't be accessed
                
                # Truncate if too long for LLM
                max_len = 15000 
                text_content_for_llm = text_content[:max_len] + ("... (truncated)" if len(text_content) > max_len else "")

                prompt = PromptTemplate(
                    input_variables=['goal', 'page_content'],
                    template="Goal: {goal}\n\nPage Content:\n{page_content}\n\nRelevant Extracted Information/Summary (respond directly with the information):"
                ).format(goal=params.goal, page_content=text_content_for_llm)
                
                response = await page_extraction_llm.ainvoke(prompt)
                extracted = response.content if hasattr(response, 'content') else str(response)
                
                msg = f'Content extracted for goal: "{params.goal}". Preview: {extracted[:100]}...'
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_content=extracted, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error in extract_content: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))


        @self.registry.action(
            'Sends special key presses or key combinations (e.g., "Enter", "Escape", "Control+A") to the page.', 
            param_model=SendKeysAction
        )
        async def send_keys(params: SendKeysAction, browser: BrowserContext) -> ActionResult:
            action_name = "send_keys"
            try:
                page = await browser.get_current_page()
                await page.keyboard.press(params.keys)
                msg = f'Sent keys: "{params.keys}".'
                logger.info(msg)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error sending keys '{params.keys}': {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
        
        @self.registry.action(
			'Scrolls the page to make the first visible occurrence of the specified text appear in the viewport.',
            param_model=ScrollToTextActionParams
		)
        async def scroll_to_text(params: ScrollToTextActionParams, browser: BrowserContext) -> ActionResult:
            action_name = "scroll_to_text"
            try:
                page = await browser.get_current_page()
                locator = page.get_by_text(params.text, exact=False)
                if await locator.count() > 0:
                    await locator.first.scroll_into_view_if_needed(timeout=10000)
                    await asyncio.sleep(0.5) 
                    msg = f'Scrolled to text: "{params.text}".'
                    return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'found_text': True})
                else:
                    msg = f'Text "{params.text}" not found on page for scrolling.'
                    return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg, 'found_text': False}) # Action succeeded, text not found
            except Exception as e:
                logger.error(f"Error scrolling to text '{params.text}': {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action(
			'Retrieves all options (text and value) from a native HTML dropdown element specified by its index.',
            param_model=GetDropdownOptionsActionParams
		)
        async def get_dropdown_options(params: GetDropdownOptionsActionParams, browser: BrowserContext) -> ActionResult:
            action_name = "get_dropdown_options"
            try:
                selector_map = await browser.get_selector_map()
                if params.index not in selector_map:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Element with index {params.index} not found.")
                
                dom_element = selector_map[params.index]
                if dom_element.tag_name.lower() != 'select':
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Element at index {params.index} is not a 'select' element.")

                element_handle = await browser.get_locate_element(dom_element)
                if not element_handle:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Could not locate select element for index {params.index}.")

                options_data = await element_handle.evaluate(
                    "(el) => Array.from(el.options).map(opt => ({text: opt.text, value: opt.value, index: opt.index, selected: opt.selected}))"
                )
                
                formatted_options = [f"Text: '{opt['text']}' (Value: '{opt['value']}') {'[Selected]' if opt['selected'] else ''}" for opt in options_data]
                result_str = "\n".join(formatted_options) if formatted_options else "No options found."
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_content=result_str, extracted_data={'message': f"Found {len(options_data)} options.", 'options_list': options_data})
            except Exception as e:
                logger.error(f"Error getting dropdown options for index {params.index}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        @self.registry.action(
			'Selects an option within a dropdown (specified by element index) by its visible text.',
            param_model=SelectDropdownOptionActionParams
		)
        async def select_dropdown_option(params: SelectDropdownOptionActionParams, browser: BrowserContext) -> ActionResult:
            action_name = "select_dropdown_option"
            try:
                selector_map = await browser.get_selector_map()
                if params.index not in selector_map:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Element with index {params.index} not found.")

                dom_element = selector_map[params.index]
                if dom_element.tag_name.lower() != 'select':
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Element at index {params.index} is not a 'select' element.")

                element_handle = await browser.get_locate_element(dom_element)
                if not element_handle:
                     return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Could not locate select element for index {params.index}.")
                
                await element_handle.select_option(label=params.text, timeout=10000)
                selected_value = await element_handle.evaluate("el => el.value")
                msg = f"Selected option with text '{params.text}' (value: '{selected_value}') in dropdown index {params.index}."
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error selecting option '{params.text}' in dropdown index {params.index}: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
        
        @self.registry.action(
			'Performs a drag and drop operation using element selectors or coordinates.',
			param_model=DragDropAction, # Uses DragDropAction from controller.views
		)
        async def drag_drop(params: DragDropAction, browser: BrowserContext) -> ActionResult:
            action_name = "drag_drop"
            page = await browser.get_current_page()
            try:
                source_pos = params.element_source_offset.model_dump() if params.element_source_offset else None
                target_pos_offset = params.element_target_offset.model_dump() if params.element_target_offset else None

                if params.element_source and params.element_target:
                    await page.locator(params.element_source).drag_to(
                        page.locator(params.element_target),
                        source_position=source_pos,
                        target_position=target_pos_offset,
                        timeout=15000
                    )
                    msg = f"Dragged '{params.element_source}' to '{params.element_target}'."
                elif params.coord_source_x is not None and params.coord_target_x is not None: # Manual mouse for coord-based
                    await page.mouse.move(float(params.coord_source_x), float(params.coord_source_y))
                    await page.mouse.down()
                    await asyncio.sleep(0.1) # Brief pause
                    await page.mouse.move(float(params.coord_target_x), float(params.coord_target_y), steps=params.steps or 5)
                    await page.mouse.up()
                    msg = f"Dragged from ({params.coord_source_x},{params.coord_source_y}) to ({params.coord_target_x},{params.coord_target_y})."
                else:
                    return self._create_action_result(action_name, params.model_dump(), success=False, error_message="Invalid drag_drop parameters.")
                
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except Exception as e:
                logger.error(f"Error during drag_drop: {e}", exc_info=True)
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))

        # --- Local PC Tool Actions (Wrapped) ---
        @self.registry.action(
            'Lists files and directories in the agent\'s workspace (Agent_Dir).',
            param_model=NoParamsAction,
        )
        async def list_agent_files(_: NoParamsAction) -> ActionResult: # Name matches system prompt
            action_name="list_agent_files"
            try:
                items = await pc_tool_list_agent_files()
                return self._create_action_result(action_name, {}, success=True, extracted_data=items or "Agent_Dir is empty.")
            except LocalPCToolError as e: return self._create_action_result(action_name, {}, success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, {}, success=False, error_message=f"Unexpected error: {str(e)}")

        @self.registry.action(
            'Reads text content from a file in Agent_Dir.',
            param_model=ReadFileParameters, # filename: str
        )
        async def read_agent_text_file(params: ReadFileParameters) -> ActionResult:
            action_name="read_agent_text_file"
            try:
                content = await pc_tool_read_agent_text_file(params.filename)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data=content)
            except (FileNotFoundInAgentDir, InvalidPathError, LocalPCFileOperationError, LocalPCToolError) as e:
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Unexpected error: {str(e)}")

        @self.registry.action(
            'Writes or appends text to a file in Agent_Dir.',
            param_model=FileParameters, # filename: str, content: str, append: bool
        )
        async def write_agent_text_file(params: FileParameters) -> ActionResult:
            action_name="write_agent_text_file"
            try:
                msg = await pc_tool_write_agent_text_file(params.filename, params.content, params.append)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except (InvalidPathError, LocalPCFileOperationError, LocalPCToolError) as e:
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Unexpected error: {str(e)}")

        @self.registry.action(
            'Reads data from an Excel file in Agent_Dir.',
            param_model=ExcelParameters, # Needs refinement for read vs write
        )
        async def read_excel_file(params: ExcelParameters) -> ActionResult:
            action_name = "read_excel_file"
            # For reading, 'data' field in ExcelParameters is not used.
            read_params_for_log = {"filename": params.filename, "sheet_name": params.sheet_name}
            try:
                data_list = await pc_tool_read_excel_file(filename=params.filename, sheet_name=params.sheet_name)
                # Return a preview or summary for extracted_content, full data in raw_tool_outputs
                preview_data = data_list[:5]
                summary_msg = f"Read {len(data_list)} rows from '{params.filename}'. Preview of first {len(preview_data)} rows shown."
                return self._create_action_result(action_name, read_params_for_log, success=True, extracted_content=summary_msg, extracted_data=data_list)
            except (FileNotFoundInAgentDir, InvalidPathError, LocalPCFileOperationError, LocalPCToolConfigurationError, LocalPCToolError) as e:
                return self._create_action_result(action_name, read_params_for_log, success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, read_params_for_log, success=False, error_message=f"Unexpected error: {str(e)}")

        @self.registry.action(
            'Writes a list of dictionaries to an Excel file in Agent_Dir.',
            param_model=ExcelParameters, # filename, data, sheet_name
        )
        async def write_excel_file(params: ExcelParameters) -> ActionResult:
            action_name = "write_excel_file"
            if params.data is None: # data is List[Dict[str, Any]] and is required for writing
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message="Parameter 'data' is required for writing to Excel.")
            try:
                msg = await pc_tool_write_excel_file(params.filename, params.data, params.sheet_name or "Sheet1")
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg})
            except (InvalidPathError, LocalPCFileOperationError, LocalPCToolConfigurationError, LocalPCToolError) as e:
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Unexpected error: {str(e)}")

        @self.registry.action(
            'Launches Notepad (Windows only), optionally opening a file from Agent_Dir.',
            param_model=LaunchNotepadParameters, # filename: Optional[str]
        )
        async def launch_notepad(params: LaunchNotepadParameters) -> ActionResult:
            action_name="launch_notepad"
            try:
                msg = await pc_tool_launch_notepad(params.filename)
                return self._create_action_result(action_name, params.model_dump(), success=True, extracted_data={'message': msg}, include_in_memory=False)
            except (InvalidPathError, LocalPCToolConfigurationError, LocalPCToolError) as e:
                return self._create_action_result(action_name, params.model_dump(), success=False, error_message=str(e))
            except Exception as e: return self._create_action_result(action_name, params.model_dump(), success=False, error_message=f"Unexpected error: {str(e)}")


    # --- Registry Decorator ---
    def action(self, description: str, **kwargs):
        """Decorator for registering custom actions from elsewhere."""
        return self.registry.action(description, **kwargs)

    # --- Act Methods (Primary: multi_act, Secondary: act) ---
    @time_execution_async('--multi_act (controller)')
    async def multi_act(
        self,
        actions_from_llm_model_instances: List[ActionModel], # AgentOutput.action provides List[ActionModel]
        browser_context: BrowserContext,
        page_extraction_llm: Optional[BaseChatModel] = None,
        sensitive_data: Optional[Dict[str, str]] = None,
        available_file_paths: Optional[List[str]] = None,
        context: Context | None = None,
    ) -> List[ActionResult]: # Returns List of ActionResult objects
        """
        Executes a list of actions (ActionModel instances) sequentially.
        """
        results: List[ActionResult] = []
        
        for i, action_model_instance in enumerate(actions_from_llm_model_instances):
            action_data = action_model_instance.model_dump(exclude_unset=True) # This gives a dict like {"action_name": {params...}}
            
            current_action_name = "unknown_action_in_sequence"
            current_params_dict: Dict[str, Any] = {}

            if not action_data or len(action_data) != 1: # Each ActionModel instance should represent one action
                logger.warning(f"Malformed ActionModel instance in sequence: {action_model_instance}. Skipping.")
                error_result = self._create_action_result(
                    action_name="malformed_action_model",
                    parameters={"malformed_action_data": str(action_model_instance)},
                    success=False,
                    error_message="Malformed action model instance received."
                )
                results.append(error_result)
                continue 

            try:
                current_action_name = next(iter(action_data.keys()))
                current_params_dict = action_data[current_action_name]
                if current_params_dict is None: current_params_dict = {} # For NoParamsAction

                log_params_display = current_params_dict
                if sensitive_data and current_action_name == "input_text" and "text" in current_params_dict and "<secret>" in current_params_dict["text"]:
                    log_params_display = {**current_params_dict, "text": "[SENSITIVE_DATA_PLACEHOLDER]"}
                
                logger.info(f"Executing action {i+1}/{len(actions_from_llm_model_instances)}: {current_action_name} with params: {log_params_display}")

                # Registry.execute_action expects params as a dict
                action_result_obj: ActionResult = await self.registry.execute_action(
                    action_name=current_action_name,
                    params=current_params_dict, 
                    browser=browser_context,
                    page_extraction_llm=page_extraction_llm,
                    sensitive_data=sensitive_data,
                    available_file_paths=available_file_paths,
                    context=context
                    # Removed action_name_arg_for_callback, _create_action_result in tools now handles name
                )
                results.append(action_result_obj)

                if action_result_obj.is_done or not action_result_obj.success:
                    log_msg = f"Action '{current_action_name}' "
                    log_msg += "marked task as done." if action_result_obj.is_done else f"failed (Error: {action_result_obj.error})."
                    log_msg += " Halting further actions in this step."
                    logger.info(log_msg)
                    break 
            
            except Exception as e:
                error_msg = f"Controller-level error executing action '{current_action_name}' in sequence: {str(e)}"
                logger.error(error_msg, exc_info=True)
                error_action_result = self._create_action_result(
                        action_name=current_action_name,
                        parameters=current_params_dict,
                        success=False,
                        error_message=error_msg
                    )
                results.append(error_action_result)
                break # Stop on critical controller error

            # Wait between actions if specified, not the last one, and current sequence hasn't been halted
            if browser_context.config.wait_between_actions > 0 and i < len(actions_from_llm_model_instances) - 1:
                # Check if the loop is about to break
                if not (results and (results[-1].is_done or not results[-1].success)):
                    logger.debug(f"Waiting for {browser_context.config.wait_between_actions}s before next action.")
                    await asyncio.sleep(browser_context.config.wait_between_actions)
        
        return results

    # Single 'act' method for compatibility or direct single action calls
    async def act(
        self,
        action_model_instance: ActionModel, 
        browser_context: BrowserContext,
        page_extraction_llm: Optional[BaseChatModel] = None,
        sensitive_data: Optional[Dict[str, str]] = None,
        available_file_paths: Optional[List[str]] = None,
        context: Context | None = None,
    ) -> ActionResult:
        """Executes a single action provided as an ActionModel instance."""
        results = await self.multi_act(
            actions_from_llm_model_instances=[action_model_instance],
            browser_context=browser_context,
            page_extraction_llm=page_extraction_llm,
            sensitive_data=sensitive_data,
            available_file_paths=available_file_paths,
            context=context
        )
        return results[0] if results else self._create_action_result("empty_single_act_result", {}, False, error_message="No result from single action execution.")