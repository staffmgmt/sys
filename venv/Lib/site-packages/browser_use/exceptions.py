# filename: newp/browser_use/exceptions.py
"""
Custom exceptions for the browser_use agent and its components.
Guideline:
- Catch specific exceptions (e.g., LLMCommunicationError, FileOperationError) when possible.
- Use broader categories (e.g., AgentRuntimeError, ToolError) if the specific cause is less clear
  but known to originate from that subsystem.
- Reserve generic `except Exception:` for truly unexpected errors, and consider re-raising
  as a more specific custom exception if context can be added.
"""

class AgentException(Exception):
    """
    Base class for all custom exceptions specifically raised by the agent
    or its core components during its operational lifecycle.
    It allows for wrapping an original exception to provide more context.
    """
    def __init__(self, message: str, original_exception: Exception | None = None):
        super().__init__(message)
        self.message = message
        self.original_exception = original_exception

    def __str__(self):
        if self.original_exception:
            # Provides a clear message including the type and message of the original error
            return f"{self.message} (Caused by: {type(self.original_exception).__name__} - {str(self.original_exception)})"
        return self.message

class AgentConfigurationError(AgentException):
    """
    Raised when there's an error in the agent's initial setup,
    configuration, or if prerequisites are not met.
    Example: Invalid settings, missing API keys if checked at this level,
             misconfigured tool registry.
    """
    pass

class AgentRuntimeError(AgentException):
    """
    Raised for general, unexpected errors occurring during the agent's
    main execution loop or step processing that are not better
    categorized by other more specific agent exceptions.
    """
    pass

class LLMCommunicationError(AgentException):
    """
    Raised specifically for errors related to communication with a Language Model.
    This can wrap lower-level exceptions from LLM client libraries (e.g., network issues,
    API authentication failures, rate limits reported by the LLM provider).
    """
    def __init__(self, message: str, status_code: int | None = None, original_exception: Exception | None = None):
        super().__init__(message, original_exception)
        self.status_code = status_code # HTTP status code, if applicable

    def __str__(self):
        base_str = super().__str__()
        if self.status_code:
            return f"LLM API Error (Status Code {self.status_code}): {base_str}"
        return f"LLM Communication Error: {base_str}"

class LLMOutputParsingError(AgentException):
    """
    Raised when the output received from the LLM cannot be parsed into
    the expected structured format (e.g., invalid JSON, schema mismatch).
    """
    def __init__(self, message: str, raw_output: str | None = None, original_exception: Exception | None = None):
        super().__init__(message, original_exception)
        self.raw_output = raw_output # Store the problematic raw output for debugging

    def __str__(self):
        base_str = super().__str__()
        if self.raw_output:
            # Provide a preview of the raw output to help diagnose parsing issues
            return f"{base_str}\nLLM Raw Output Preview (first 200 chars): '{self.raw_output[:200]}...'"
        return base_str

class PlannerError(AgentException):
    """
    Raised for errors specific to the agent's internal planning or
    reflection module's logic or its dedicated interaction with an LLM.
    """
    pass

class MaxStepsReachedError(AgentRuntimeError):
    """
    Raised when the agent reaches its maximum configured number of steps
    for a given task without achieving a 'done' state.
    """
    def __init__(self, max_steps: int, task_id: str | None = None):
        message = f"Agent execution stopped: Maximum step limit of {max_steps} reached."
        if task_id:
            message += f" Task ID: {task_id}"
        super().__init__(message)
        self.max_steps = max_steps
        self.task_id = task_id

class AgentInterruptedError(AgentRuntimeError):
    """
    Raised when the agent's operation is deliberately interrupted,
    for example, by a user signal (Ctrl+C resulting in pause/stop)
    or an external stop request.
    """
    pass

# The original LLMException from the uploaded file.
# It can be retained for compatibility if it's directly caught elsewhere,
# or fully replaced by LLMCommunicationError.
# For a unified hierarchy, making it inherit from AgentException is good.
class LLMException(AgentException): # Changed to inherit from AgentException
    """
    Specific exception for LLM-related errors, often including an HTTP status code.
    This version is kept for broader compatibility if specific `status_code` handling exists.
    New code should prefer raising `LLMCommunicationError` for clarity.
    """
    def __init__(self, message: str, status_code: int | None = None, original_exception: Exception | None = None):
        # Construct a message that includes the status code if present for the superclass
        # The superclass's __str__ will handle appending original_exception info.
        if status_code is not None:
            full_message = f"LLM Error (Status Code {status_code}): {message}"
        else:
            full_message = f"LLM Error: {message}"
        super().__init__(full_message, original_exception)
        self.status_code = status_code
        # The message attribute in AgentException will store the full_message.
        # If you need the original short message separately:
        # self.short_message = message 

    # The __str__ from AgentException will be used. If a different format is needed:
    # def __str__(self):
    #     prefix = f"Error {self.status_code}: " if self.status_code else "LLM Error: "
    #     base_msg = self.message # This will be the full_message from __init__
    #     # To get only the short message part, you'd need to store it separately in __init__.
    #     # For now, AgentException's __str__ is fine.
    #     return f"{prefix}{self.message}" # This would duplicate the prefix if AgentException.__str__ is also complex.
    #     # Relying on AgentException.__str__() is cleaner.


# Note on ToolError:
# ToolError and its derivatives (FileNotFoundInAgentDir, InvalidPathError, etc.)
# are defined in `browser_use/local_pc_tools.py` as they are specific to that module.
# If a single common base for *all* exceptions in the `browser_use` package (including tools)
# is desired, ToolError could also be made to inherit from AgentException.
# For example, in local_pc_tools.py:
#   from browser_use.exceptions import AgentException
#   class ToolError(AgentException): ...
# This would allow catching AgentException to get any error originating from the agent system or its tools.
# For now, ToolError remains independent as per its current definition in local_pc_tools.py.