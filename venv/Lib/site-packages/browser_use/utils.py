# filename: newp/browser_use/utils.py
import asyncio
import logging
import os
import platform
import signal
import time
import re
from functools import wraps
from sys import stderr
from typing import Any, Callable, Coroutine, List, Optional, ParamSpec, TypeVar, Type

logger = logging.getLogger(__name__)

# Global flag to prevent duplicate exit messages if SignalHandler is invoked multiple times
_exiting_signal_handler = False

# Define generic type variables for return type and parameters
R = TypeVar('R')
P = ParamSpec('P')


# --- Timeout Context Manager (Fix for C2) ---
class Timeout:
    """
    An asynchronous context manager for enforcing a timeout on a block of code.
    Raises asyncio.TimeoutError if the block does not complete within the specified duration.
    """
    def __init__(self, seconds: Optional[float]):
        self._timeout_seconds = seconds
        self._task: Optional[asyncio.Task] = None

    async def __aenter__(self):
        if self._timeout_seconds is None: # No timeout
            return self

        # Get the current event loop
        loop = asyncio.get_running_loop()
        # Schedule a an asyncio.TimeoutError to be raised in the current task
        # after _timeout_seconds.
        self_task = asyncio.current_task(loop)
        if self_task is None: # Should not happen in async context manager
            raise RuntimeError("Timeout context manager used outside of an asyncio task.")

        self._task = loop.create_task(self._timeout_raiser(self_task, loop))
        return self

    async def _timeout_raiser(self, task_to_cancel: asyncio.Task, loop: asyncio.AbstractEventLoop):
        try:
            await asyncio.sleep(self._timeout_seconds) # type: ignore
            # If the sleep completes, it means the timeout was reached.
            # Cancel the original task and raise TimeoutError in it.
            if not task_to_cancel.done():
                # Create a TimeoutError to be raised in the target task
                # We can't directly raise in another task, but cancelling and then
                # the task awaiting something that was cancelled will raise CancelledError.
                # A more direct way is to have the task check a flag or use asyncio.wait_for.
                # For simplicity here, we'll rely on the task being responsive to cancellation.
                task_to_cancel.cancel(msg=f"Operation timed out after {self._timeout_seconds} seconds.")
        except asyncio.CancelledError:
            # This task itself was cancelled (e.g., if the main block finished early)
            pass # Nothing to do, the main block completed or was cancelled otherwise

    async def __aexit__(self, exc_type: Optional[Type[BaseException]],
                        exc_val: Optional[BaseException],
                        exc_tb: Optional[Any]): # Traceback type is complex
        if self._task is not None and not self._task.done():
            self._task.cancel()
            # Suppress CancelledError if this task is cancelled because main block finished
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        
        # If the timeout occurred and CancelledError was raised in the main task,
        # it might be desirable to re-raise it as asyncio.TimeoutError.
        # However, Playwright and other libraries often raise their own TimeoutError
        # which might be caught before this __aexit__ converts a CancelledError.
        # If exc_type is asyncio.CancelledError and self._task raised the cancellation,
        # it implies the timeout mechanism initiated the cancel.
        if exc_type is asyncio.CancelledError and self._task and self._task.done() and not self._task.cancelled():
             # Check if our timeout_raiser task completed normally (meaning it triggered the cancel)
             # This logic is a bit indirect. A more robust way might involve asyncio.wait_for
             # or direct exception injection if the framework allowed.
             # For now, if CancelledError, we let it propagate. Agent.step handles TimeoutError/asyncio.TimeoutError.
            pass
        
        return None # Do not suppress other exceptions unless specifically handled


# --- Signal Handler ---
class SignalHandler:
	"""
	A modular and reusable signal handling system for managing SIGINT (Ctrl+C), SIGTERM,
	and other signals in asyncio applications.
	"""
	def __init__(
		self,
		loop: Optional[asyncio.AbstractEventLoop] = None,
		pause_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None, # Callback can be async
		resume_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None, # Callback can be async
		custom_exit_callback: Optional[Callable[[], Coroutine[Any, Any, None]]] = None, # Callback can be async
		exit_on_second_int: bool = True,
		interruptible_task_patterns: Optional[List[str]] = None,
	):
		self.loop = loop or asyncio.get_event_loop()
		self.pause_callback = pause_callback
		self.resume_callback = resume_callback
		self.custom_exit_callback = custom_exit_callback
		self.exit_on_second_int = exit_on_second_int
		self.interruptible_task_patterns: List[str] = interruptible_task_patterns or ['Agent.step', 'Controller.multi_act', 'Agent.get_next_action'] # More specific default patterns
		self.is_windows = platform.system() == 'Windows'
		self._ctrl_c_pressed_count = 0
		self._original_sigint_handler: Any = None
		self._original_sigterm_handler: Any = None
		self._is_registered = False


	def _reset_ctrl_c_count(self):
		self._ctrl_c_pressed_count = 0

	async def _execute_callback(self, callback: Optional[Callable[[], Coroutine[Any, Any, None]]]):
		if callback:
			try:
				await callback()
			except Exception as e:
				logger.error(f"Error in SignalHandler callback '{getattr(callback, '__name__', 'unnamed_callback')}': {e}", exc_info=True)

	def register(self) -> None:
		"""Register signal handlers for SIGINT and SIGTERM."""
		if self._is_registered:
			return
		try:
			if self.is_windows:
				# On Windows, signal handling in asyncio loops can be tricky.
				# A common approach for Ctrl+C is to let it raise KeyboardInterrupt.
				# We can catch KeyboardInterrupt in the main application loop.
				# For SIGTERM, it's less commonly used/handled this way on Windows.
				logger.info("Signal handling on Windows is simplified (Ctrl+C raises KeyboardInterrupt).")
				# No specific asyncio handlers added on Windows by this class directly.
				# Applications should catch KeyboardInterrupt.
			else:
				self._original_sigint_handler = signal.getsignal(signal.SIGINT)
				self.loop.add_signal_handler(signal.SIGINT, self._sigint_handler_async_wrapper)
				
				self._original_sigterm_handler = signal.getsignal(signal.SIGTERM)
				self.loop.add_signal_handler(signal.SIGTERM, self._sigterm_handler_async_wrapper)
			self._is_registered = True
		except (ValueError, RuntimeError, AttributeError) as e:
			# ValueError: "signal only works in main thread"
			# RuntimeError: "set_wakeup_fd only works in main thread" (uvloop)
			# AttributeError: if loop is not the main loop's and doesn't support add_signal_handler well
			logger.warning(f"Signal handlers could not be registered (likely not in main thread or unsupported environment): {e}")


	def unregister(self) -> None:
		"""Unregister signal handlers and restore original handlers if possible."""
		if not self._is_registered:
			return
		try:
			if not self.is_windows:
				self.loop.remove_signal_handler(signal.SIGINT)
				if self._original_sigint_handler is not None:
					signal.signal(signal.SIGINT, self._original_sigint_handler)
				
				self.loop.remove_signal_handler(signal.SIGTERM)
				if self._original_sigterm_handler is not None:
					signal.signal(signal.SIGTERM, self._original_sigterm_handler)
		except (ValueError, RuntimeError) as e:
			logger.warning(f'Error while unregistering signal handlers: {e}')
		finally:
			self._is_registered = False
			self._original_sigint_handler = None
			self._original_sigterm_handler = None

	def _sigint_handler_async_wrapper(self):
		"""Wrapper to call the async SIGINT handler."""
		asyncio.create_task(self._async_sigint_handler())

	def _sigterm_handler_async_wrapper(self):
		"""Wrapper to call the async SIGTERM handler."""
		asyncio.create_task(self._async_sigterm_handler())

	async def _async_sigint_handler(self) -> None:
		"""Async SIGINT (Ctrl+C) handler."""
		global _exiting_signal_handler
		if _exiting_signal_handler: # Already in process of exiting
		    print('\n🛑 Force exiting due to repeated Ctrl+C during shutdown...\n', file=stderr)
		    os._exit(1) # Force exit

		self._ctrl_c_pressed_count += 1

		if self._ctrl_c_pressed_count == 1:
			logger.info("Ctrl+C pressed. Attempting to pause and cancel current step...")
			print('----------------------------------------------------------------------', file=stderr)
			print('🛑 Ctrl+C detected. Pausing agent execution...', file=stderr)
			print('   Cancelling current operations. Please wait...', file=stderr)
			
			await self._cancel_interruptible_tasks()
			if self.pause_callback:
				await self._execute_callback(self.pause_callback) # Agent.pause() sets state to PAUSED

			# Wait for resume or second Ctrl+C
			await self._wait_for_resume_or_exit()

		elif self.exit_on_second_int:
			print('\n🛑 Second Ctrl+C pressed. Exiting application immediately...\n', file=stderr)
			_exiting_signal_handler = True
			if self.custom_exit_callback:
				await self._execute_callback(self.custom_exit_callback)
			os._exit(1) # Force exit
		# If not exiting on second int, subsequent Ctrl+C might be ignored or handled by _wait_for_resume_or_exit

	async def _wait_for_resume_or_exit(self) -> None:
		"""Internal: Waits for user input to resume or exit after first Ctrl+C."""
		# This part is tricky with asyncio. input() is blocking.
		# The agent's main loop in agent/service.py::run() now has a check for AgentStatus.PAUSED
		# and sleeps, allowing other tasks. The actual user input for resume/exit
		# needs to be handled carefully not to block the loop if other things must run.
		# For a command-line tool, a simple blocking input() in a separate thread or
		# relying on the agent loop's pause state might be sufficient.
		# The original code's input() approach would block the thread where signal handler runs.

		# This method will now primarily message the user. The resume is handled by Agent.resume()
		# which can be triggered externally or via another mechanism if this were a server.
		# For a CLI, a simple input prompt is okay if agent is truly paused.
		
		green = '\x1b[32;1m'
		red = '\x1b[31m'
		blink = '\033[33;5m'
		reset = '\x1b[0m'
		
		# Give user instructions. Actual resume call comes from elsewhere (e.g. Agent.resume())
		print(f'➡️  Agent paused. To resume, call agent.resume(). To exit, press {red}[Ctrl+C]{reset} again.{blink}...{reset}', file=stderr)
		# The agent state is PAUSED. The main loop in agent.service.py will be in its sleep cycle.
		# If another Ctrl+C comes, _async_sigint_handler handles it.

	async def _async_sigterm_handler(self) -> None:
		"""Async SIGTERM handler."""
		global _exiting_signal_handler
		if not _exiting_signal_handler:
			_exiting_signal_handler = True
			print('\n🛑 SIGTERM received. Initiating graceful shutdown...\n', file=stderr)
			logger.info("SIGTERM received. Initiating graceful shutdown...")
			
			# Attempt to cancel tasks and run exit callback
			await self._cancel_interruptible_tasks(force_cancel_all=True) # Force cancel all on SIGTERM
			if self.custom_exit_callback:
				await self._execute_callback(self.custom_exit_callback)
			
			print('🛑 Shutdown complete. Exiting.', file=stderr)
			os._exit(0) # Clean exit after attempts

	async def _cancel_interruptible_tasks(self, force_cancel_all: bool = False) -> None:
		"""Cancel current tasks that match patterns or all tasks if force_cancel_all."""
		current_task = asyncio.current_task(self.loop)
		tasks_to_cancel = []

		for task in asyncio.all_tasks(self.loop):
			if task == current_task or task.done():
				continue
			
			task_name = task.get_name() if hasattr(task, 'get_name') else str(task)
			if force_cancel_all or any(pattern in task_name for pattern in self.interruptible_task_patterns):
				tasks_to_cancel.append(task)
		
		if current_task and not current_task.done(): # Also consider current task
		    task_name = current_task.get_name() if hasattr(current_task, 'get_name') else str(current_task)
		    if force_cancel_all or any(pattern in task_name for pattern in self.interruptible_task_patterns):
		        if current_task not in tasks_to_cancel: # Avoid double add if it was already an "other" task somehow
		             tasks_to_cancel.append(current_task)


		if not tasks_to_cancel:
			logger.debug("No interruptible tasks found to cancel.")
			return

		logger.debug(f"Attempting to cancel {len(tasks_to_cancel)} tasks...")
		for task in tasks_to_cancel:
			task_name = task.get_name() if hasattr(task, 'get_name') else str(task)
			logger.debug(f"Cancelling task: {task_name}")
			task.cancel("Signal received, cancelling task.")
		
		# Give cancelled tasks a moment to process cancellation
		# Using gather to wait for them, but supressing CancelledError from gather itself
		# Timeout for this wait can be short.
		await asyncio.gather(*tasks_to_cancel, return_exceptions=True)
		logger.debug("Relevant tasks have been requested to cancel.")


	def resume_execution(self) -> None:
		"""Called by Agent.resume() to reset signal handler state."""
		logger.info("Signal handler state reset for resume.")
		self._reset_ctrl_c_count()
		if self.resume_callback: # This callback is on Agent to change its state
		    asyncio.create_task(self._execute_callback(self.resume_callback))


# --- Execution Timing Decorators ---
def time_execution_sync(additional_text: str = '') -> Callable[[Callable[P, R]], Callable[P, R]]:
	def decorator(func: Callable[P, R]) -> Callable[P, R]:
		@wraps(func)
		def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
			start_time = time.monotonic() # Use monotonic for measuring intervals
			result = func(*args, **kwargs)
			execution_time = time.monotonic() - start_time
			logger.debug(f'SYNC {func.__name__}{additional_text} execution time: {execution_time:.4f} seconds')
			return result
		return wrapper
	return decorator


def time_execution_async(
	additional_text: str = '',
) -> Callable[[Callable[P, Coroutine[Any, Any, R]]], Callable[P, Coroutine[Any, Any, R]]]:
	def decorator(func: Callable[P, Coroutine[Any, Any, R]]) -> Callable[P, Coroutine[Any, Any, R]]:
		@wraps(func)
		async def wrapper(*args: P.args, **kwargs: P.kwargs) -> R:
			start_time = time.monotonic()
			result = await func(*args, **kwargs)
			execution_time = time.monotonic() - start_time
			logger.debug(f'ASYNC {func.__name__}{additional_text} execution time: {execution_time:.4f} seconds')
			return result
		return wrapper
	return decorator


# --- Singleton Decorator ---
def singleton(cls: Type[R]) -> Callable[..., R]:
	instance = [None] # Using a list to allow modification in closure
	lock = asyncio.Lock() # For thread/async safety during first instantiation

	@wraps(cls)
	async def async_wrapper(*args: Any, **kwargs: Any) -> R: # Make wrapper async if class init might be
		if instance[0] is None:
			async with lock:
				if instance[0] is None: # Double check after acquiring lock
					# If __init__ is async, await it. Otherwise, call directly.
					# This assumes __init__ is synchronous. If it can be async, inspect.iscoroutinefunction(cls.__init__) would be needed.
					instance[0] = cls(*args, **kwargs)
		return instance[0] # type: ignore

	@wraps(cls)
	def sync_wrapper(*args: Any, **kwargs: Any) -> R:
	    # This is the one from user's file, assuming it's for sync singletons mostly
	    if instance[0] is None:
	        # The lock here is a standard threading.Lock if used in sync context.
	        # For simplicity, if this singleton is only for sync classes, threading.Lock is fine.
	        # If it could be called from async code for a sync class, then a simple check is usually okay if init is fast.
	        # The original was `instance = [None]` which isn't thread-safe for creation.
	        # Let's keep it simple as per the original intent for now, assuming non-concurrent first calls or fast init.
	        instance[0] = cls(*args, **kwargs)
	    return instance[0] # type: ignore

    # Decide which wrapper to return. If the class might be used in async contexts for init,
    # or if its methods are async, an async-aware singleton might be better.
    # The original snippet just had `instance=[None]` and `instance[0] = cls(...)`.
    # Sticking to the simpler sync_wrapper as per original file structure.
	return sync_wrapper


# --- Environment Variable Check ---
def check_env_variables(keys: List[str], check_all: bool = True) -> bool: # Renamed any_or_all to check_all for clarity
	"""Check if all (or any if check_all=False) required environment variables are set and non-empty."""
	op = all if check_all else any
	return op(bool(os.getenv(key, '').strip()) for key in keys)

def redact_sensitive_data(text: str, sensitive_data_map: Optional[dict[str, str]]) -> str:
    """
    Redacts sensitive data from a given text string for logging purposes.
    First, it replaces known sensitive values (from sensitive_data_map) with placeholders.
    Then, if any <secret>placeholder</secret> patterns (newly created or pre-existing)
    are found, the entire string is replaced with a generic "[SENSITIVE_DATA]" message
    to avoid leaking placeholder names themselves in logs.
    """
    if not text or not isinstance(text, str): # Handle non-string or empty text
        return text

    redacted_text = text

    if sensitive_data_map:
        for placeholder_key, actual_value in sensitive_data_map.items():
            if actual_value and isinstance(actual_value, str) and actual_value in redacted_text:
                # Ensure placeholder_key is a simple string for the tag
                safe_placeholder_key = re.sub(r'\W+', '_', placeholder_key) 
                redacted_text = redacted_text.replace(actual_value, f"<secret>{safe_placeholder_key}</secret>")

    # If, after replacements or originally, the text contains any secret placeholder format,
    # then simplify the log output to a generic message to avoid leaking placeholder names.
    if "<secret>" in redacted_text and "</secret>" in redacted_text:
         # More robustly find any placeholder content and generalize
         # This regex finds <secret>ANYTHING_HERE</secret>
        if re.search(r"<secret>.*?</secret>", redacted_text):
            return "[SENSITIVE_DATA]"

    return redacted_text