# browser_use/agent/views.py

from __future__ import annotations

import enum
import json
import logging 
import uuid
from dataclasses import dataclass 
from pathlib import Path
from typing import Any, Dict, List, Literal, Optional, Type, Union, TYPE_CHECKING

from langchain_core.language_models.chat_models import BaseChatModel 
from pydantic import BaseModel, ConfigDict, Field, create_model 

# Imports from within the browser_use package
from browser_use.agent.message_manager.views import MessageManagerState 
from browser_use.browser.views import BrowserStateHistory 

# Issue 3 Fix: Import from controller.views instead of redefining
from browser_use.controller.views import (
    FileParameters, ReadFileParameters, ExcelParameters, LaunchNotepadParameters
)
# ActionModel base is imported from controller.registry.views
from browser_use.controller.registry.views import ActionModel 


logger = logging.getLogger(__name__) 
ToolCallingMethod = Literal['function_calling', 'json_mode', 'raw', 'auto'] 

REQUIRED_LLM_API_ENV_VARS = {
	'ChatOpenAI': ['OPENAI_API_KEY'],
	'AzureOpenAI': ['AZURE_ENDPOINT', 'AZURE_OPENAI_API_KEY'],
	'ChatBedrockConverse': ['ANTHROPIC_API_KEY'], 
	'ChatAnthropic': ['ANTHROPIC_API_KEY'],
	'ChatGoogleGenerativeAI': ['GEMINI_API_KEY'], 
	'ChatDeepSeek': ['DEEPSEEK_API_KEY'],
	'ChatOllama': [],
	'ChatGrok': ['GROK_API_KEY'],
}


class AgentStatus(str, enum.Enum):
    PENDING = "PENDING"
    RUNNING = "RUNNING"
    REFLECTING = "REFLECTING"  
    RECOVERING = "RECOVERING"  
    PAUSED = "PAUSED"
    STOPPED = "STOPPED" 
    COMPLETED = "COMPLETED" 
    FAILED = "FAILED" 
    MAX_STEPS_REACHED = "MAX_STEPS_REACHED" 

class AgentSettings(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='ignore')

    use_vision: bool = Field(True, description="Enable vision capabilities for the main LLM if the model supports it.")
    use_vision_for_planner: bool = Field(True, description="Enable passing screenshots to the planner/reflector LLM if it supports vision.")
    save_conversation_path: Optional[str] = Field(None, description="Directory path to save conversation steps. If None, conversation is not saved to disk.")
    save_conversation_path_encoding: str = Field('utf-8', description="Encoding for saved conversation files.")
    max_failures: int = Field(3, ge=1, description="Maximum consecutive failures before the agent stops processing the task.")
    retry_delay: int = Field(10, ge=0, description="Delay in seconds for retrying LLM calls or certain recoverable actions.")
    max_steps: int = Field(100, ge=1, description="Maximum number of steps the agent is allowed to take for the current task.") # Added field
    max_input_tokens: int = Field(128000, description="Maximum input tokens to be considered for the main LLM prompt context.")
    validate_output: bool = Field(False, description="Enable validation of the agent's final output against a schema or criteria (conceptual).")
    message_context: Optional[str] = Field(None, description="Additional contextual string to be included in LLM prompts (via MessageManager).")
    generate_gif: Union[bool, str] = Field(False, description="Generate a GIF of the agent's browser interactions. If a string, it's the output path.")
    available_file_paths: Optional[List[str]] = Field(None, description="List of specific file paths the agent is allowed to access (for MessageManager & Controller).")
    override_system_message: Optional[str] = Field(None, description="A complete system message to override the default.")
    extend_system_message: Optional[str] = Field(None, description="Additional text to append to the default system message.")
    include_attributes: List[str] = Field(
        default=[
            'title', 'type', 'name', 'role', 'tabindex',
            'aria-label', 'placeholder', 'value', 'alt', 'aria-expanded',
        ],
        description="List of HTML attributes to include in the DOM representation sent to the LLM (via MessageManager)."
    )
    max_actions_per_step: int = Field(7, ge=1, description="Maximum number of actions the agent can plan and attempt to execute in a single step.")
    step_interval: float = Field(0.5, ge=0, description="Minimum interval in seconds between the end of one step and the beginning of the next.")
    step_timeout: int = Field(300, ge=10, description="Timeout in seconds for a single agent step to complete before being considered failed.")

    tool_calling_method: Optional[ToolCallingMethod] = Field('auto', description="Method for tool calling by the LLM (e.g., 'function_calling', 'json_mode'). Resolved in Agent init.")
    page_extraction_llm: Optional[BaseChatModel] = Field(None, description="Optional separate LLM dedicated for page content extraction tasks (passed to Controller).")

    # --- Planner Settings ---
    planner_llm: Optional[BaseChatModel] = Field(None, description="LLM to use for the internal planner/reflection cycle. If None and use_planner is True, defaults to the main agent LLM.")
    use_planner: bool = Field(True, description="Enable the internal reflection and planning cycle. Defaults to True.") # CHANGED DEFAULT
    planner_interval: int = Field(7, ge=1, description="Run planner/reflector at the start of every N steps (e.g., N=7 means on step 0, 7, 14...).") # CHANGED DEFAULT
    is_planner_reasoning: bool = Field(False, description="Controls if the planner prompt encourages more verbose chain-of-thought style reasoning (prompt engineering detail).")

    reflect_on_error: bool = Field(True, description="Trigger the reflection/planning cycle immediately after a step results in an error and agent enters RECOVERING state.")
    reflect_on_state_change: bool = Field(False, description="Trigger reflection on major state changes (conceptual).")

    save_final_summary_to_db: bool = Field(False, description="Conceptual: Save the final memory summary to a database for future learning.")
    load_initial_summary_from_db: bool = Field(False, description="Conceptual: Load an initial memory summary from a database based on the task.")
    save_learned_strategies: bool = Field(False, description="Save effective strategies identified by the planner to files in Agent_Dir.")

    image_tokens: int = Field(default=800, description="Default token cost for images if not overridden (for MessageManager).")
    estimated_characters_per_token: int = Field(default=4, description="Default character per token estimate (for MessageManager).")
    recent_message_window_priority: int = Field(default=5, description="Number of recent conversational turns to prioritize in truncation (for MessageManager).")

    browser_config: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Configuration for the main Browser instance.")
    default_browser_context_config: Optional[Dict[str, Any]] = Field(default_factory=dict, description="Default configuration for new BrowserContext instances.")


class AgentState(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='ignore')

    agent_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique identifier for this agent instance.")
    status: AgentStatus = Field(AgentStatus.PENDING, description="Current operational status of the agent.")
    n_steps: int = Field(0, description="Number of steps successfully initiated or completed by the agent.") 
    max_steps: int = Field(100, ge=1, description="Maximum number of steps the agent is allowed to take for the current task.")
    consecutive_failures: int = Field(0, ge=0, description="Number of consecutive steps that have resulted in failure.")
    last_result: Optional[List[ActionResult]] = Field(None, description="The result(s) of the last action(s) taken in the previous step.")
    last_error: Optional[str] = Field(None, description="Description of the last error encountered by the agent, used for recovery context.")
    history: AgentHistoryList = Field(default_factory=lambda: AgentHistoryList(history=[]))
    current_goal: Optional[str] = Field("Initiate the task based on user instructions.", description="The current high-level goal or strategy guiding the agent, potentially set by the planner.")
    current_memory_summary: Optional[str] = Field(None, description="The latest consolidated summary of progress and findings, updated by the planner.")
    
    message_manager_state: MessageManagerState = Field(default_factory=MessageManagerState)
    task: Dict[str, Any] = Field(default_factory=dict, description="Structured information about the current task (e.g., id, instructions, user_id).")
    accumulated_output: Optional[str] = Field(None, description="Final accumulated output or answer from the agent upon task completion or failure.")
    

@dataclass
class AgentStepInfo: 
    step_number: int
    max_steps: int

    def is_last_step(self) -> bool:
        return self.step_number >= self.max_steps - 1


class ActionResult(BaseModel):
    model_config = ConfigDict(extra='forbid') 

    action_name: str = Field(description="Name of the action that was executed (e.g., 'click_element_by_index', 'read_agent_text_file').")
    parameters: Optional[Dict[str, Any]] = Field(None, description="Parameters provided to the action.")
    success: bool = Field(description="Whether the action executed successfully without raising an operational error.")
    is_done: bool = Field(False, description="Indicates if this action signifies the completion of the overall task (e.g., successful 'done' action).")
    extracted_content: Optional[str] = Field(None, description="Any textual content extracted or generated by the action (e.g., text from a webpage, content of a read file, summary from a tool). The Controller will populate this from various raw output keys.")
    error: Optional[str] = Field(None, description="Error message if the action failed during its execution.")
    include_in_memory: bool = Field(False, description="Whether this action's result (especially extracted_content or error) should be included in the short-term memory for the next LLM prompt.")
    raw_tool_outputs: Optional[Dict[str, Any]] = Field(None, description="The raw, direct dictionary output from the tool, if applicable, before any specific field extraction. Useful for debugging or if the LLM needs more details.")


class StepMetadata(BaseModel):
    model_config = ConfigDict(extra='ignore') 
    step_number: int = Field(description="The sequence number of this step in the agent's run.")
    step_start_time: float = Field(description="Timestamp (time.time()) when the step started.")
    step_end_time: float = Field(description="Timestamp (time.time()) when the step ended.")
    input_tokens: Optional[int] = Field(None, description="Number of tokens in the prompt sent to the main LLM for this step.")
    completion_tokens: Optional[int] = Field(None, description="Number of tokens generated by the main LLM in its response for this step.")
    prompt_tokens: Optional[int] = Field(None, description="Often the same as input_tokens; specific token count for the prompt part if provided by the LLM service.")
    total_tokens: Optional[int] = Field(None, description="Total tokens used for the main LLM call in this step (prompt + completion).")

    @property
    def duration_seconds(self) -> float:
        return self.step_end_time - self.step_start_time


class AgentBrain(BaseModel):
    model_config = ConfigDict(extra='forbid')
    
    prior_action_assessment: str = Field(description="Succinct evaluation of the previous step's action(s) outcome(s) (e.g., 'Success: Navigated to homepage and located login button.', 'Failed: File write operation failed due to permissions.').")
    task_log: str = Field(description="A concise, running log of the task's current state, key findings from web interactions or Agent_Dir file operations, and immediate objectives for *this* step based on the overall goal.")
    next_goal: str = Field(description="The specific, immediate, and actionable goal that the planned action(s) in *this* step aim to achieve. This should be a refinement of or step towards the agent's current_goal from AgentState.")


class AgentOutput(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True, extra='forbid')
    current_state: AgentBrain = Field(description="The agent's assessment of its current state and immediate plan based on observations.")
    action: List[ActionModel] = Field(..., min_length=1, description="A list of actions to be executed sequentially in the current step to achieve the stated next_goal.")

    @staticmethod
    def type_with_custom_actions(custom_actions_model: Type[ActionModel]) -> Type[AgentOutput]:
        if not (isinstance(custom_actions_model, type) and issubclass(custom_actions_model, BaseModel)):
            raise TypeError("custom_actions_model must be a Pydantic model class.")
        
        model_name = f'AgentOutput_{custom_actions_model.__name__}'
        created_model = create_model(
            model_name,
            __base__=AgentOutput,
            current_state=(AgentBrain, Field(..., description=AgentOutput.model_fields['current_state'].description)),
            action=(List[custom_actions_model], Field(..., min_length=1, description=AgentOutput.model_fields['action'].description)), # type: ignore
            __module__=AgentOutput.__module__, 
        )
        created_model.__doc__ = f'AgentOutput model dynamically restricted to actions defined in {custom_actions_model.__name__}'
        return created_model


class AgentHistory(BaseModel):
    model_config = ConfigDict(arbitrary_types_allowed=True, protected_namespaces=(), extra='ignore')
    
    step: int = Field(description="The step number in the agent's run, corresponding to AgentState.n_steps at the beginning of the step.")
    browser_state: Optional[BrowserStateHistory] = Field(None, description="Snapshot of the browser state relevant to this step (e.g., after observation, before action, or after action).")
    agent_output: Optional[AgentOutput] = Field(None, description="The agent's structured output (thoughts and planned actions) for this step.")
    action_results: List[ActionResult] = Field(description="A list of results from each action executed in this step.")
    metadata: Optional[StepMetadata] = Field(None, description="Metadata associated with this step's execution (timing, token counts, etc.).")
    

class ReflectionPlannerOutput(BaseModel):
    model_config = ConfigDict(extra='forbid') 
    
    memory_summary: str = Field(description="A concise but comprehensive summary of key progress, findings, obstacles encountered, current Agent_Dir state, and relevant context learned since the last reflection. This updates AgentState.current_memory_summary.")
    next_goal: str = Field(description="The immediate high-level strategic goal or direction for the next phase of the task. This updates AgentState.current_goal.")
    effective_strategy: Optional[str] = Field(None, description="Optional: A brief description of a reusable strategy, pattern, learning, or tactical approach identified during reflection that proved effective or could be useful.")


class AgentHistoryList(BaseModel):
    model_config = ConfigDict(extra='ignore')
    history: List[AgentHistory] = Field(default_factory=list)

    def __str__(self) -> str:
        return f'AgentHistoryList(number_of_steps={self.number_of_steps()}, is_done={self.is_done()}, is_successful={self.is_successful()})'

    def __repr__(self) -> str:
        return self.__str__()

    @property
    def number_of_steps(self) -> int:
        return len(self.history)

    def is_done(self) -> bool:
        if not self.history:
            return False
        last_step_results = self.history[-1].action_results
        return any(res.is_done for res in last_step_results) if last_step_results else False

    def is_successful(self) -> Optional[bool]:
        if not self.is_done():
            return None
        last_step_results = self.history[-1].action_results
        for res in last_step_results:
            if res.is_done:
                return res.success 
        return False 

    def total_duration_seconds(self) -> float:
        return sum(h.metadata.duration_seconds for h in self.history if h.metadata and h.metadata.duration_seconds is not None)

    def action_names(self) -> List[str]:
        names = set()
        for history_item in self.history:
            for action_result in history_item.action_results:
                names.add(action_result.action_name)
        return sorted(list(names))
        
    def model_thoughts(self) -> List[Optional[AgentBrain]]:
        return [h.agent_output.current_state if h.agent_output else None for h in self.history]

    def save_to_file(self, filepath: Union[str, Path]) -> None:
        try:
            path = Path(filepath)
            path.parent.mkdir(parents=True, exist_ok=True)
            data = self.model_dump(mode='json', exclude_none=True)
            with path.open('w', encoding='utf-8') as f:
                json.dump(data, f, indent=2)
            logger.info(f"Agent history successfully saved to {filepath}")
        except Exception as e:
            logger.error(f"Failed to save agent history to {filepath}: {e}", exc_info=True)
            raise

    @classmethod
    def load_from_file(cls, filepath: Union[str, Path], agent_output_action_model: Type[ActionModel]) -> AgentHistoryList:
        try:
            with Path(filepath).open('r', encoding='utf-8') as f:
                data = json.load(f)
            
            DynamicAgentOutput = AgentOutput.type_with_custom_actions(agent_output_action_model)
            
            parsed_history_items: List[AgentHistory] = []
            for item_data in data.get('history', []):
                if item_data.get('agent_output') and isinstance(item_data['agent_output'], dict):
                    try:
                        item_data['agent_output'] = DynamicAgentOutput.model_validate(item_data['agent_output'])
                    except Exception as e:
                        step_num = item_data.get('step', 'Unknown')
                        logger.warning(
                            f"Failed to parse 'agent_output' for step {step_num} with dynamic type '{DynamicAgentOutput.__name__}'. Error: {e}. "
                            f"Agent output data: {item_data['agent_output']}"
                        )
                        item_data['agent_output'] = None 
                
                try:
                    parsed_history_items.append(AgentHistory.model_validate(item_data))
                except Exception as e:
                    step_num = item_data.get('step', 'Unknown')
                    logger.error(f"Failed to validate AgentHistory item for step {step_num}: {e}. Data: {item_data}", exc_info=True)

            return cls(history=parsed_history_items)
        except Exception as e:
            logger.error(f"Failed to load agent history from {filepath}: {e}", exc_info=True)
            raise

# --- Local PC Tool Parameter Models ---
# These are now imported from browser_use.controller.views to avoid duplication.