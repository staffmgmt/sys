# filename: newp/browser_use/local_pc_tools.py
import asyncio
import logging
import os
import platform
import subprocess
from pathlib import Path
from typing import Any, Dict, List, Optional, Union

import pandas as pd # type: ignore # For Excel operations; ensure pandas & openpyxl are in requirements.txt

logger = logging.getLogger(__name__)

# --- Configuration: Agent Directory Setup ---
try:
    # Assumes this file is in newp/browser_use/
    # Navigates up two levels to newp/ (project root)
    PROJECT_ROOT = Path(__file__).resolve().parent.parent
except NameError:
    # Fallback if __file__ is not defined (e.g., interactive session)
    # This defaults to current working directory. Adjust if execution context differs.
    PROJECT_ROOT = Path(".").resolve()
    logger.warning(
        f"__file__ not defined. PROJECT_ROOT defaulted to current working directory: {PROJECT_ROOT}. "
        "Ensure this is correct for AGENT_DIR_PATH resolution."
    )

AGENT_DIR_NAME = "Agent_Dir"  # Name of the agent's sandboxed working directory
AGENT_DIR_PATH = (PROJECT_ROOT / AGENT_DIR_NAME).resolve()

# Ensure the Agent_Dir exists upon module load
try:
    AGENT_DIR_PATH.mkdir(parents=True, exist_ok=True)
    logger.info(f"Agent working directory ensured at: {AGENT_DIR_PATH}")
except OSError as e:
    logger.error(f"CRITICAL: Could not create or access agent directory {AGENT_DIR_PATH}: {e}")
    # This is a fatal error for tool operation.
    raise RuntimeError(f"Failed to initialize agent directory at {AGENT_DIR_PATH}: {e}") from e

# Path to Notepad, specific to Windows
NOTEPAD_PATH_WINDOWS = r"C:\Windows\system32\notepad.exe"


# --- Custom Exceptions for Local PC Tools ---
class ToolError(Exception):
    """Base class for errors originating from local_pc_tools."""
    pass

class FileOperationError(ToolError):
    """Indicates an error during a file read/write operation."""
    pass

class FileNotFoundInAgentDir(FileOperationError):
    """Specific error when a requested file is not found within the AGENT_DIR_PATH."""
    def __init__(self, filename: str, search_path: Path):
        super().__init__(f"File '{filename}' not found within agent directory '{search_path}'.")
        self.filename = filename
        self.search_path = search_path

class InvalidPathError(ToolError):
    """Indicates that a provided path is invalid, disallowed, or attempts traversal."""
    pass

class ToolConfigurationError(ToolError):
    """Indicates an error related to tool configuration or prerequisites (e.g., OS-specific tool not available)."""
    pass


# --- Path Validation Helper ---
def _validate_path(
    filename: str,
    target_dir: Path = AGENT_DIR_PATH, # Ensure this default is always what we want
    must_exist: bool = False,
    allowed_extensions: Optional[List[str]] = None,
    check_is_file: bool = True # If must_exist, also check if it's a file (unless explicitly for dirs)
) -> Path:
    """
    Validates that the given filename resolves to a path strictly within the target_dir.
    Prevents directory traversal and enforces other security/validity checks.

    Args:
        filename: The filename or relative path string.
        target_dir: The root directory within which the path must reside.
        must_exist: If True, the resolved path must exist.
        allowed_extensions: Optional list of allowed file extensions (e.g., ['.txt', '.csv']).
                            Comparison is case-insensitive.
        check_is_file: If True and must_exist is True, also verifies the path is a file.

    Returns:
        A resolved, validated Path object.

    Raises:
        InvalidPathError: If the path is invalid, attempts traversal, or has disallowed characters/extensions.
        FileNotFoundInAgentDir: If must_exist is True and the file is not found.
        FileOperationError: If must_exist and check_is_file are True, but path is not a file.
    """
    if not filename or not isinstance(filename, str):
        raise InvalidPathError("Filename must be a non-empty string.")

    # Disallow absolute paths and explicit traversals in the input string itself
    # Path(filename).is_absolute() checks for OS-specific absolute paths
    if Path(filename).is_absolute() or '..' in Path(filename).parts:
        raise InvalidPathError(
            f"Invalid filename '{filename}'. Must be a relative path within Agent_Dir, without traversal ('..') or absolute components."
        )

    # Check for characters often problematic in filenames across OSes (excluding path separators)
    # Slashes are handled by Path object construction.
    # This list can be expanded based on stricter needs.
    problematic_chars = ['<', '>', ':', '"', '|', '?', '*'] 
    # Check only the filename part for these characters if it's a path
    name_component_to_check = Path(filename).name
    if any(char in name_component_to_check for char in problematic_chars):
        raise InvalidPathError(f"Invalid characters detected in filename component '{name_component_to_check}'. Forbidden chars: {' '.join(problematic_chars)}")

    # Construct the full path relative to the target_dir
    # .resolve() makes it absolute and canonical (resolves symlinks, normalizes '..')
    full_path = (target_dir / Path(filename)).resolve()

    # CRITICAL SECURITY CHECK: Ensure the resolved path is truly within the target_dir.
    # Path.is_relative_to() is Python 3.9+. Using os.path.commonpath for broader compatibility.
    # After resolving, compare common prefix.
    if os.path.commonpath([str(target_dir.resolve()), str(full_path)]) != str(target_dir.resolve()):
        raise InvalidPathError(
            f"Path traversal attempt for filename '{filename}'. Operation outside designated agent directory '{target_dir}' is forbidden. Resolved to '{full_path}'"
        )

    if allowed_extensions:
        normalized_allowed_extensions = [ext.lower().strip() for ext in allowed_extensions]
        file_suffix_lower = full_path.suffix.lower().strip()
        if not file_suffix_lower or file_suffix_lower not in normalized_allowed_extensions: # Ensure suffix exists before check
            raise InvalidPathError(
                f"Invalid file extension for '{filename}'. Allowed extensions: {', '.join(allowed_extensions)}. Got: '{full_path.suffix}'"
            )

    if must_exist:
        if not full_path.exists():
            raise FileNotFoundInAgentDir(filename, target_dir)
        if check_is_file and not full_path.is_file():
            raise FileOperationError(f"Path '{filename}' exists but is not a file (it's a directory or other type).")
    
    return full_path


# --- Tool Implementations (Async) ---

async def list_agent_files() -> List[str]:
    """
    Lists all files and directories directly within the AGENT_DIR_PATH.
    Returns a list of names, with '/' appended to directory names.
    """
    logger.debug(f"Listing files in agent directory: {AGENT_DIR_PATH}")
    if not AGENT_DIR_PATH.is_dir(): # Should have been created, but good to check
         raise FileOperationError(f"Agent directory not found or invalid: {AGENT_DIR_PATH}")

    def _list_items_blocking():
        items = []
        for item in AGENT_DIR_PATH.iterdir():
            items.append(f"{item.name}{'/' if item.is_dir() else ''}")
        return items
    
    try:
        items = await asyncio.to_thread(_list_items_blocking)
        logger.info(f"Successfully listed {len(items)} items in {AGENT_DIR_PATH}.")
        return items
    except Exception as e:
        logger.error(f"Error listing agent directory {AGENT_DIR_PATH}: {e}", exc_info=True)
        raise FileOperationError(f"An error occurred while listing files in agent directory: {str(e)}")


async def read_agent_text_file(filename: str) -> str:
    """
    Reads the content of a specified text file from the AGENT_DIR_PATH.
    Allowed extensions ensure it's a text-like file.
    """
    allowed_text_extensions = ['.txt', '.md', '.csv', '.json', '.log', '.py', '.js', '.html', '.xml', '.yaml', '.yml', '.sh', '.css']
    logger.debug(f"Attempting to read text file: {filename} from {AGENT_DIR_PATH}")
    try:
        file_path = _validate_path(filename, must_exist=True, allowed_extensions=allowed_text_extensions, check_is_file=True)
        
        def _read_blocking():
            return file_path.read_text(encoding='utf-8', errors='replace')
        
        content = await asyncio.to_thread(_read_blocking)
        logger.info(f"Successfully read text file: {file_path.name}")
        return content
    except (InvalidPathError, FileNotFoundInAgentDir, FileOperationError) as e: # Specific, validated errors
        logger.warning(f"Failed to read text file '{filename}': {e}")
        raise e # Re-raise for controller to handle
    except Exception as e: # Catch-all for other unexpected IO errors
        logger.error(f"Unexpected error reading text file '{filename}': {e}", exc_info=True)
        raise FileOperationError(f"An unexpected error occurred while reading file '{filename}': {str(e)}")


async def write_agent_text_file(filename: str, content: str, append: bool = False) -> str:
    """
    Writes or appends text content to a specified file in the AGENT_DIR_PATH.
    Creates the file if it doesn't exist. Parent directories are also created if needed.
    Allowed extensions ensure it's a text-like file.
    """
    allowed_text_extensions = ['.txt', '.md', '.csv', '.json', '.log', '.py', '.js', '.html', '.xml', '.yaml', '.yml', '.sh', '.css']
    logger.debug(f"Attempting to {'append to' if append else 'write to'} text file: {filename} in {AGENT_DIR_PATH}")
    try:
        # For writing, must_exist is False. _validate_path ensures it's within Agent_Dir.
        file_path = _validate_path(filename, must_exist=False, allowed_extensions=allowed_text_extensions, check_is_file=False) # check_is_file=False as it might not exist
        
        def _write_blocking():
            # Ensure parent directory exists before writing
            file_path.parent.mkdir(parents=True, exist_ok=True)
            mode = 'a' if append else 'w'
            with file_path.open(mode, encoding='utf-8') as f:
                return f.write(content)
        
        bytes_written = await asyncio.to_thread(_write_blocking)
        action_str = 'appended to' if append else 'written to'
        success_message = f"Successfully {action_str} file '{file_path.name}' ({bytes_written} characters)."
        logger.info(success_message)
        return success_message
    except (InvalidPathError, FileOperationError) as e: # Specific, validated errors
        logger.error(f"Failed to write text file '{filename}': {e}")
        raise e
    except Exception as e: # Catch-all for other unexpected IO errors
        logger.error(f"Unexpected error writing text file '{filename}': {e}", exc_info=True)
        raise FileOperationError(f"An unexpected error occurred while writing file '{filename}': {str(e)}")


async def read_excel_file(filename: str, sheet_name: Union[str, int, None] = 0) -> List[Dict[str, Any]]:
    """
    Reads data from an Excel file (.xlsx, .xls) within AGENT_DIR_PATH.
    Returns data as a list of dictionaries, where each dictionary represents a row.
    """
    allowed_excel_extensions = ['.xlsx', '.xls']
    logger.debug(f"Attempting to read Excel file: {filename}, sheet: {sheet_name} from {AGENT_DIR_PATH}")
    try:
        file_path = _validate_path(filename, must_exist=True, allowed_extensions=allowed_excel_extensions, check_is_file=True)
        
        def _read_excel_blocking():
            # pandas.read_excel can read from a path object directly.
            # sheet_name=None reads all sheets. Default to 0 (first sheet) if None is passed by caller.
            actual_sheet_name = sheet_name if sheet_name is not None else 0
            df = pd.read_excel(file_path, sheet_name=actual_sheet_name, engine='openpyxl' if file_path.suffix == '.xlsx' else None)
            # Replace NaN/NaT with None for JSON compatibility for Pydantic models
            return df.astype(object).where(pd.notnull(df), None).to_dict(orient="records")

        data = await asyncio.to_thread(_read_excel_blocking)
        logger.info(f"Successfully read {len(data)} rows from Excel file: {file_path.name}, sheet: {sheet_name if sheet_name is not None else '0'}.")
        return data
    except (InvalidPathError, FileNotFoundInAgentDir, FileOperationError) as e:
        logger.warning(f"Failed to read Excel file '{filename}': {e}")
        raise e
    except ImportError: # Pandas or openpyxl might not be installed
        logger.error("Pandas or openpyxl library not installed. Cannot perform Excel operations.")
        raise ToolConfigurationError("Required library for Excel (pandas/openpyxl) not installed.")
    except Exception as e: # Catches errors from pandas (e.g., bad file format, sheet not found)
        logger.error(f"Error reading Excel file '{filename}': {e}", exc_info=True)
        if "No sheet named" in str(e) or isinstance(e, ValueError) and "Excel file format cannot be determined" in str(e) or "File is not a zip file" in str(e): # More specific pandas errors
             raise FileOperationError(f"Failed to read Excel file '{filename}': Invalid format or sheet '{sheet_name}' not found. Error: {e}")
        raise FileOperationError(f"An unexpected error occurred while reading Excel file '{filename}': {str(e)}")


async def write_excel_file(filename: str, data: List[Dict[str, Any]], sheet_name: str = "Sheet1") -> str:
    """
    Writes data (list of dictionaries) to an Excel file (.xlsx) in AGENT_DIR_PATH.
    Each dictionary in the list represents a row.
    """
    # Typically stick to .xlsx for writing with openpyxl, which is pandas' default for .xlsx
    allowed_excel_extensions = ['.xlsx'] 
    logger.debug(f"Attempting to write {len(data)} rows to Excel file: {filename}, sheet: {sheet_name} in {AGENT_DIR_PATH}")
    try:
        file_path = _validate_path(filename, must_exist=False, allowed_extensions=allowed_excel_extensions, check_is_file=False)
        
        if not data: # Handle empty data case gracefully
            logger.warning(f"Writing empty data to Excel file '{filename}'. An empty sheet will be created/overwritten.")
            df = pd.DataFrame([])
        else:
            df = pd.DataFrame(data)

        def _write_excel_blocking():
            file_path.parent.mkdir(parents=True, exist_ok=True)
            df.to_excel(file_path, sheet_name=sheet_name, index=False, engine='openpyxl')
        
        await asyncio.to_thread(_write_excel_blocking)
        success_message = f"Successfully wrote {len(df)} rows to Excel file '{file_path.name}', sheet '{sheet_name}'."
        logger.info(success_message)
        return success_message
    except (InvalidPathError, FileOperationError) as e:
        logger.error(f"Failed to write Excel file '{filename}': {e}")
        raise e
    except ImportError:
        logger.error("Pandas or openpyxl library not installed. Cannot perform Excel write operations.")
        raise ToolConfigurationError("Required library for Excel (pandas/openpyxl) not installed.")
    except Exception as e:
        logger.error(f"Unexpected error writing Excel file '{filename}': {e}", exc_info=True)
        raise FileOperationError(f"An unexpected error occurred while writing Excel file '{filename}': {str(e)}")


async def launch_notepad(filename: Optional[str] = None) -> str:
    """
    Launches Notepad.exe on Windows.
    If a filename (relative to AGENT_DIR_PATH) is provided, it attempts to open that file with Notepad.
    """
    logger.debug(f"Attempting to launch Notepad, optional file: {filename}")
    if platform.system() != "Windows":
        logger.warning("Launch Notepad tool called on a non-Windows system.")
        raise ToolConfigurationError("Notepad tool is only available on Windows operating systems.")

    if not Path(NOTEPAD_PATH_WINDOWS).exists():
        logger.error(f"Notepad executable not found at configured path: {NOTEPAD_PATH_WINDOWS}")
        raise ToolConfigurationError(f"Notepad executable not found at {NOTEPAD_PATH_WINDOWS}. Cannot launch.")

    command = [NOTEPAD_PATH_WINDOWS]
    file_to_open_display_name = "Notepad"
    
    try:
        if filename:
            # Validate path is within Agent_Dir. Notepad can create a new file, so must_exist=False.
            # Allowed extensions can be broader for Notepad.
            allowed_notepad_extensions = ['.txt', '.md', '.log', '.csv', '.json', '.py', '.js', '.html', '.xml', '.yaml', '.yml', '.ini', '.cfg', '.conf']
            file_path_to_open = _validate_path(filename, must_exist=False, allowed_extensions=allowed_notepad_extensions, check_is_file=False)
            command.append(str(file_path_to_open))
            file_to_open_display_name = f"Notepad with '{file_path_to_open.name}'"

        def _launch_blocking():
            # subprocess.Popen is non-blocking by default in terms of starting the process.
            # However, if we needed to wait for it or interact, asyncio.create_subprocess_exec would be better.
            # For just launching, Popen in a thread is fine to avoid blocking the main async loop if Popen itself had some sync setup.
            process = subprocess.Popen(command)
            return process.pid # Return PID for logging, though we don't manage the process after launch.

        pid = await asyncio.to_thread(_launch_blocking)
        success_message = f"Successfully launched {file_to_open_display_name} (PID: {pid})."
        logger.info(success_message)
        return success_message
    except InvalidPathError as e: # Catch validation errors for the optional filename
        logger.error(f"Invalid filename for Notepad '{filename}': {e}")
        raise e
    except ToolConfigurationError as e: # Catch if Notepad path itself is bad (already checked, but good practice)
        logger.error(f"Tool configuration error for Notepad: {e}")
        raise e
    except Exception as e: # Catch other errors during Popen or path validation
        logger.error(f"Error launching Notepad with '{filename}': {e}", exc_info=True)
        raise ToolError(f"An unexpected error occurred while launching Notepad: {str(e)}")